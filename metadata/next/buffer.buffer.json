{"name":"buffer.Buffer","summary":"<p>The <code>Buffer</code> class is a global type for dealing with binary data directly. It can be constructed in a variety of ways.</p>\n","extends":"Object","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"type":"pseudo","editUrl":"https://github.com/appcelerator/titanium_mobile/edit/master/apidoc/NodeJS/buffer.yml","methods":[{"name":"compare","summary":"<p>Compares <code>buf</code> with <code>target</code> and returns a number indicating whether buf comes before, after, or is the same as target in sort order. Comparison is based on the actual sequence of bytes in each <code>Buffer</code>.</p>\n","description":"<p><code>0</code> is returned if target is the same as buf\n<code>1</code> is returned if target should come before buf when sorted.\n<code>-1</code> is returned if target should come after buf when sorted.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"target","summary":"<p>A <code>Buffer</code> or <code>Uint8Array</code> with which to compare buf.</p>\n","type":["buffer.Buffer","Uint8Array"]},{"name":"targetStart","summary":"<p>The offset within target at which to begin comparison.</p>\n","type":"Number","optional":true},{"name":"targetEnd","summary":"<p>The offset within target at which to end comparison (not inclusive).</p>\n","type":"Number","optional":true},{"name":"sourceStart","summary":"<p>The offset within buf at which to begin comparison.</p>\n","type":"Number","optional":true},{"name":"sourceEnd","summary":"<p>The offset within buf at which to end comparison (not inclusive).</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"copy","summary":"<p>Copies data from a region of <code>buf</code> to a region in <code>target</code>, even if the target memory region overlaps with <code>buf</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"target","summary":"<p>A <code>Buffer</code> or <code>Uint8Array</code> with which to compare buf.</p>\n","type":["buffer.Buffer","Uint8Array"]},{"name":"targetStart","summary":"<p>The offset within target at which to begin writing.</p>\n","type":"Number","optional":true},{"name":"sourceStart","summary":"<p>The offset within buf at which to begin copying.</p>\n","type":"Number","optional":true},{"name":"sourceEnd","summary":"<p>The offset within buf at which to stop copying (not inclusive).</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p>The number of bytes copied.</p>\n","type":"Number"}},{"name":"entries","summary":"<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol\">iterator</a> of <code>[index, byte]</code> pairs from the contents of <code>buf</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"returns":{"type":"Object"}},{"name":"equals","summary":"<p>Returns <code>true</code> if both <code>buf</code> and <code>otherBuffer</code> have exactly the same bytes, false otherwise. Equivalent to <code>buf.compare(otherBuffer) === 0</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"otherBuffer","summary":"<p>A <code>Buffer</code> or <code>Uint8Array</code> with which to compare buf.</p>\n","type":["buffer.Buffer","Uint8Array"]}],"returns":{"type":"Boolean"}},{"name":"fill","summary":"<p>Fills <code>buf</code> with the specified value. If the <code>offset</code> and <code>end</code> are not given, the entire <code>buf</code> will be filled.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>The value with which to fill <code>buf</code>.</p>\n","type":["String","Number","buffer.Buffer","Uint8Array"]},{"name":"offset","summary":"<p>Number of bytes to skip before starting to fill <code>buf</code>.</p>\n","type":"Number","optional":true},{"name":"end","summary":"<p>Where to stop filling <code>buf</code> (not inclusive).</p>\n","type":"Number","optional":true},{"name":"encoding","summary":"<p>The encoding for <code>value</code> if <code>value</code> is a string.</p>\n","type":"String","optional":true}],"returns":{"summary":"<p>A reference to <code>buf</code>.</p>\n","type":"buffer.Buffer"}},{"name":"includes","summary":"<p>Equivalent to <code>buf.indexOf() !== -1</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>What to search for.</p>\n","type":["String","Number","buffer.Buffer","Uint8Array"]},{"name":"byteOffset","summary":"<p>Where to begin searching in <code>buf</code>. If negative, then offset is calculated from the end of <code>buf</code>.</p>\n","type":"Number","optional":true},{"name":"encoding","summary":"<p>If <code>value</code> is a string, this is its encoding.</p>\n","type":"String","optional":true}],"returns":{"summary":"<p><code>true</code> if <code>value</code> was found in buf, <code>false</code> otherwise.</p>\n","type":"Boolean"}},{"name":"indexOf","summary":"<p>If value is:</p>\n<ul>\n<li>a string, <code>value</code> is interpreted according to the character encoding in <code>encoding</code>.</li>\n<li>a <code>Buffer</code> or <code>Uint8Array</code>, value will be used in its entirety. To compare a partial <code>Buffer</code>, use <a href=\"/api/structs/buffer/buffer.html#slice\">slice</a>.</li>\n<li>a number, <code>value</code> will be interpreted as an unsigned 8-bit integer value between <code>0</code> and <code>255</code>.</li>\n</ul>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>What to search for.</p>\n","type":["String","Number","buffer.Buffer","Uint8Array"]},{"name":"byteOffset","summary":"<p>Where to begin searching in <code>buf</code>. If negative, then offset is calculated from the end of <code>buf</code>.</p>\n","type":"Number","optional":true},{"name":"encoding","summary":"<p>If <code>value</code> is a string, this is the encoding used to determine the binary representation of the string that will be searched for in <code>buf</code>.</p>\n","type":"String","optional":true}],"returns":{"summary":"<p>The index of the first occurrence of <code>value</code> in <code>buf</code>, or <code>-1</code> if <code>buf</code> does not contain <code>value</code>.</p>\n","type":"Number"}},{"name":"keys","summary":"<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol\">iterator</a> of <code>buf</code> keys (indices).</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"returns":{"type":"Object"}},{"name":"lastIndexOf","summary":"<p>Identical to <code>buf.indexOf()</code>, except the last occurrence of <code>value</code> is found rather than the first occurrence.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>What to search for.</p>\n","type":["String","Number","buffer.Buffer","Uint8Array"]},{"name":"byteOffset","summary":"<p>Where to begin searching in <code>buf</code>. If negative, then offset is calculated from the end of <code>buf</code>.</p>\n","type":"Number","optional":true},{"name":"encoding","summary":"<p>If <code>value</code> is a string, this is the encoding used to determine the binary representation of the string that will be searched for in <code>buf</code>.</p>\n","type":"String","optional":true}],"returns":{"summary":"<p>The index of the last occurrence of <code>value</code> in <code>buf</code>, or <code>-1</code> if <code>buf</code> does not contain <code>value</code>.</p>\n","type":"Number"}},{"name":"readDoubleBE","summary":"<p>Reads a 64-bit, big-endian double from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 8</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readDoubleLE","summary":"<p>Reads a 64-bit, little-endian double from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 8</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readFloatBE","summary":"<p>Reads a 32-bit, big-endian float from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readFloatLE","summary":"<p>Reads a 32-bit, little-endian float from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readInt16BE","summary":"<p>Reads a signed 16-bit, big-endian integer from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readInt16LE","summary":"<p>Reads a signed 16-bit, little-endian integer from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readInt32BE","summary":"<p>Reads a signed 32-bit, big-endian integer from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readInt32LE","summary":"<p>Reads a signed 32-bit, little-endian integer from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readInt8","summary":"<p>Reads a signed 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<p>Integers read from a Buffer are interpreted as two's complement signed values.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 1</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readIntBE","summary":"<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code> and interprets the result as a big-endian, two's complement signed value supporting up to 48 bits of accuracy.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</p>\n","type":"Number"},{"name":"byteLength","summary":"<p>Number of bytes to read. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</p>\n","type":"Number"}],"returns":{"type":"Number"}},{"name":"readIntLE","summary":"<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code> and interprets the result as a little-endian, two's complement signed value supporting up to 48 bits of accuracy.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</p>\n","type":"Number"},{"name":"byteLength","summary":"<p>Number of bytes to read. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</p>\n","type":"Number"}],"returns":{"type":"Number"}},{"name":"readUInt16BE","summary":"<p>Reads an unsigned 16-bit, big-endian integer from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readUInt16LE","summary":"<p>Reads an unsigned 16-bit, little-endian integer from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readUInt32BE","summary":"<p>Reads an unsigned 32-bit, big-endian integer from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readUInt32LE","summary":"<p>Reads an unsigned 32-bit, little-endian integer from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readUInt8","summary":"<p>Reads an unsigned 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 1</code>.</p>\n","type":"Number","optional":true}],"returns":{"type":"Number"}},{"name":"readUIntBE","summary":"<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code> and interprets the result as an unsigned big-endian value supporting up to 48 bits of accuracy.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</p>\n","type":"Number"},{"name":"byteLength","summary":"<p>Number of bytes to read. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</p>\n","type":"Number"}],"returns":{"type":"Number"}},{"name":"readUIntLE","summary":"<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code> and interprets the result as an unsigned little-endian value supporting up to 48 bits of accuracy.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"offset","summary":"<p>Number of bytes to skip before starting to read. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</p>\n","type":"Number"},{"name":"byteLength","summary":"<p>Number of bytes to read. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</p>\n","type":"Number"}],"returns":{"type":"Number"}},{"name":"slice","summary":"<p>Returns a new <code>Buffer</code> that references the same memory as the original, but offset and cropped by the <code>start</code> and <code>end</code> indices.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"start","summary":"<p>here the new Buffer will start.</p>\n","type":"Number","optional":true},{"name":"end","summary":"<p>Where the new Buffer will end (not inclusive).</p>\n","type":"Number","optional":true}],"returns":{"type":"buffer.Buffer"}},{"name":"subarray","summary":"<p>Returns a new <code>Buffer</code> that references the same memory as the original, but offset and cropped by the <code>start</code> and <code>end</code> indices.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"start","summary":"<p>here the new Buffer will start.</p>\n","type":"Number","optional":true},{"name":"end","summary":"<p>Where the new Buffer will end (not inclusive).</p>\n","type":"Number","optional":true}],"returns":{"type":"buffer.Buffer"}},{"name":"swap16","summary":"<p>Interprets <code>buf</code> as an array of unsigned 16-bit integers and swaps the byte order <em>in-place</em>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"returns":{"type":"buffer.Buffer"}},{"name":"swap32","summary":"<p>Interprets <code>buf</code> as an array of unsigned 32-bit integers and swaps the byte order <em>in-place</em>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"returns":{"type":"buffer.Buffer"}},{"name":"swap64","summary":"<p>Interprets <code>buf</code> as an array of unsigned 64-bit integers and swaps the byte order <em>in-place</em>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"returns":{"type":"buffer.Buffer"}},{"name":"toJSON","summary":"<p>Returns a JSON representation of <code>buf</code>. <code>JSON.stringify()</code> implicitly calls this function when stringifying a <code>Buffer</code> instance.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"returns":{"type":"Object"}},{"name":"toString","summary":"<p>Decodes <code>buf</code> to a string according to the specified character encoding in <code>encoding</code>. <code>start</code> and <code>end</code> may be passed to decode only a subset of <code>buf</code>.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"encoding","summary":"<p>The character encoding to use.</p>\n","type":"String","optional":true},{"name":"start","summary":"<p>The byte offset to start decoding at.</p>\n","type":"Number","optional":true},{"name":"end","summary":"<p>The byte offset to stop decoding at (not inclusive).</p>\n","type":"Number","optional":true}],"returns":{"type":"String"}},{"name":"values","summary":"<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol\">iterator</a> for <code>buf</code> values (bytes). This function is called automatically when a <code>Buffer</code> is used in a <code>for..of</code> statement.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"returns":{"type":"Object"}},{"name":"write","summary":"<p>Writes <code>string</code> to <code>buf</code> at <code>offset</code> according to the character encoding in <code>encoding</code>. The <code>length</code> parameter is the number of bytes to write. If <code>buf</code> did not contain enough space to fit the entire string, only part of <code>string</code> will be written. However, partially encoded characters will not be written.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"string","summary":"<p>String to write to <code>buf</code>.</p>\n","type":"String"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write string.</p>\n","type":"Number","optional":true},{"name":"length","summary":"<p>Maximum number of bytes to write (written bytes will not exceed buf.length - offset).</p>\n","type":"Number","optional":true},{"name":"encoding","summary":"<p>The character encoding of string.</p>\n","type":"String","optional":true}],"returns":{"summary":"<p>Number of bytes written.</p>\n","type":"Number"}},{"name":"writeDoubleBE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. The <code>value</code> must be a JavaScript number. Behavior is undefined when <code>value</code> is anything other than a JavaScript number.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 8</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeDoubleLE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. The <code>value</code> must be a JavaScript number. Behavior is undefined when <code>value</code> is anything other than a JavaScript number.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 8</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeFloatBE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. The <code>value</code> must be a JavaScript number. Behavior is undefined when <code>value</code> is anything other than a JavaScript number.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeFloatLE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. The <code>value</code> must be a JavaScript number. Behavior is undefined when <code>value</code> is anything other than a JavaScript number.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeInt16BE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid signed 16-bit integer. Behavior is undefined when <code>value</code> is anything other than a signed 16-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeInt16LE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid signed 16-bit integer. Behavior is undefined when <code>value</code> is anything other than a signed 16-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeInt32BE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid signed 32-bit integer. Behavior is undefined when <code>value</code> is anything other than a signed 32-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeInt32LE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid signed 32-bit integer. Behavior is undefined when <code>value</code> is anything other than a signed 32-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeInt8","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid signed 8-bit integer. Behavior is undefined when <code>value</code> is anything other than a signed 8-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two's complement signed integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 1</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeIntBE","summary":"<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is anything other than a signed integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</p>\n","type":"Number"},{"name":"byteLength","summary":"<p>Number of bytes to write. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</p>\n","type":"Number"}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeIntLE","summary":"<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is anything other than a signed integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</p>\n","type":"Number"},{"name":"byteLength","summary":"<p>Number of bytes to write. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</p>\n","type":"Number"}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeUInt16BE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid unsigned 16-bit integer. Behavior is undefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeUInt16LE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid unsigned 16-bit integer. Behavior is undefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 2</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeUInt32BE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid unsigned 32-bit integer. Behavior is undefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeUInt32LE","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid unsigned 32-bit integer. Behavior is undefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 4</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeUInt8","summary":"<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> must be a valid unsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything other than an unsigned 8-bit integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - 1</code>.</p>\n","type":"Number","optional":true}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeUIntBE","summary":"<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code> as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is anything other than an unsigned integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</p>\n","type":"Number"},{"name":"byteLength","summary":"<p>Number of bytes to write. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</p>\n","type":"Number"}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}},{"name":"writeUIntLE","summary":"<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code> as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is anything other than an unsigned integer.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"parameters":[{"name":"value","summary":"<p>Number to be written to <code>buf</code>.</p>\n","type":"Number"},{"name":"offset","summary":"<p>Number of bytes to skip before starting to write. Must satisfy <code>0 &lt;= offset &lt;= buf.length - byteLength</code>.</p>\n","type":"Number"},{"name":"byteLength","summary":"<p>Number of bytes to write. Must satisfy <code>0 &lt; byteLength &lt;= 6</code>.</p>\n","type":"Number"}],"returns":{"summary":"<p><code>offset</code> plus the number of bytes written.</p>\n","type":"Number"}}],"properties":[{"name":"buffer","summary":"<p>The underlying <code>ArrayBuffer</code> object based on which this <code>Buffer</code> object is created.</p>\n","description":"<p>This <code>ArrayBuffer</code> is not guaranteed to correspond exactly to the original <code>Buffer</code>. See the notes on <a href=\"/api/structs/buffer/buffer.html#byteoffset\">byteOffset</a> for details.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"type":"ArrayBuffer"},{"name":"byteOffset","summary":"<p>The <code>byteOffset</code> of the <code>Buffer</code>s underlying <code>ArrayBuffer</code> object.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"type":"Number"},{"name":"length","summary":"<p>Returns the number of bytes in buf.</p>\n","platforms":[{"since":"8.2.0","name":"android"},{"since":"8.2.0","name":"iphone"},{"since":"8.2.0","name":"ipad"},{"since":"9.2.0","name":"macos"}],"type":"Number"}],"events":[],"constants":[]}
